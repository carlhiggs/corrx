---
title: "Corrx: Classical Twin Study Power Calculator and Simulation Reference"
output: 
  flexdashboard::flex_dashboard:
    orientation: columns
    vertical_layout: fill
    source_code: embed
    theme: flatly
runtime: shiny

---


```{r setup, include=FALSE}
# Carl Higgs, 2019

library(flexdashboard)
library(knitr)
library(shiny)
library(ggplot2)
library(scales)
library(dplyr)
library(reshape2)
library(data.table)

# plan(multiprocess)
# read.csv.async <- function(file) {
#   future({
#     read.csv(file,  header = TRUE, stringsAsFactors=FALSE)
#   })
# }

  
```
Calculator
==========

Inputs {.sidebar}
-----------------------------------------------------------------------
An interactive calculator of power for detecting difference in correlations.  The calculator uses either an analytic formula, or draws upon pre-processed simulation power results for a given set of scenario parameters.

Twins Research Australia, 2019.

```{r, shiny_in}
# shiny inputs defined here
hr()

selectInput("power", "Select target power percentage: ", choices =c('80', '90') ,selected = '80')
selectInput("skewness", "Select variable skewness: ", choices =c('normal', 'mild', 'extreme') ,selected = 'normal')
selectInput("corr_method", "Select correlation method: ", choices =c('Pearson', 'Spearman') ,selected = 'normal')
# selectInput("power_method", "Select Fisher's Z implementation: ", choices =c('analytical', 'simulation') ,selected = 'analytical')
sliderInput("ratio", "Ratio of Mz to Dz twin:", min=0, max=10, value=1, step=0.01)
# sliderInput("rho1", "Corr(x,y) in Mz twins:",min=0, max=1, value=0.6, step=0.01)
sliderInput("rho2", "Corr(x,y) in Dz twins:",min=0.0, max=1.0, value=0.2, step=0.01)
    
hr()

```


Outputs
-----------------------------------------------------------------------
    
### Calculator (<i>set parameters to view plot</i>)
```{r}

# load data
corrx_1k_sim <-read.csv("corrx_1k_subset.csv",  header = TRUE, stringsAsFactors=FALSE) 

```



```{r}
server <- function(input, output) {
power_obs <- reactive({
  corrx_1k_sim %...>%
        filter(
                 # method == "pearson" &
                 # dist   == "normal" &
                 # n1/n2  == 1 &
                 # rho2   == .5
                 method == input$corr_method &
                 dist   == input$skewness    &
                 n1/n2  == input$ratio       &
                 rho2   == input$rho2
              ) %...>%
        select(n1,n2,rho1,fz_nosim,fz)  %...>%
        mutate(n = n1 + n2) %...>%
        mutate(log_n = log2(n)) %...>%
        select(n,rho1,fz_nosim,fz)  %...>%
        melt(
           id.vars=c("n","rho1"),
          measure.vars=c("fz_nosim","fz"),
          variable.name="test",
          value.name="power")
  })
# power_obs()

power_estimate <- reactive({
  corrx_1k_sim %...>%
    filter(method == input$corr_method &
             dist == input$skewness    &
             round(log(n1/n2),2) == round(log(input$ratio),2) &
             rho1 == 0.4       &
             rho2 == 0.9
    ) 
})  
  
  
mydata <- reactive({
    # Model Parameters:
      r1        <- .1
      r2        <- .5 # input$rho2
      rdiff     <- r1 - r2
      maxn      <- 2000
      mzdz      <- 1 # input$ratio
      # alpha     <- input$alpha
      sidedness <- 2
      # method    <- input$method
      method    <- "pearson" # input$corr_method
      skew      <- input$skewness
      # Step 1: calculate Fisher's Z
      z1        <- atanh(r1)
      z2        <- atanh(r2)
      # Step    2: take difference
      zdiff     <- z1-z2
      # Step    3: calculate standard errmzor and test statistic
      tot_n         <- 15:maxn
      mzdz_vec <- seq(0,10,0.01)
      # n_p1         <- cbind(mz = tot_n*mzdz,dz = tot_n*(1-mzdz))
      n_p1         <- cbind(mz = tot_n/(mzdz+1)*mzdz,dz = tot_n/(mzdz+1))
      n_p2         <- cbind(mz = maxn/(mzdz_vec+1)*mzdz_vec,dz = maxn/(mzdz_vec+1))
      z_se_p1      <- sqrt(rowSums(1/(n_p1-3)))
      z_se_p2      <- sqrt(rowSums(1/(n_p2-3)))
      z_test_p1    <- zdiff/z_se_p1
      z_test_p2    <- zdiff/z_se_p2
      # optionally return p-value for observing diff at least this large under H0
      # z_p    <- sidedness*pnorm(-abs(z_test))
      z_ref    <- c(qnorm(1-0.1/2),qnorm(1-0.05/2))
      z_power1a <- 1-pnorm(z_ref[1] - abs(z_test_p1))
      z_power1b <- 1-pnorm(z_ref[2] - abs(z_test_p1))
      z_power1  <- rbind(cbind(z_power1a,z_ref[1]),cbind(z_power1b,z_ref[2]))
      z_power2a <- 1-pnorm(z_ref[1] - abs(z_test_p2))
      z_power2b <- 1-pnorm(z_ref[2] - abs(z_test_p2))
      z_power2  <- rbind(cbind(z_power2a,z_ref[1]),cbind(z_power2b,z_ref[2]))
      colnames(z_power1) <- colnames(z_power2) <- c("power","ref")
      
    # Collect and output results
    params1 <- paste0("MZ:DZ ratio: ",mzdz,"; rho_mz: ",r1,"; rho_dz: ",r2,"; delta: ",rdiff)
    params2 <- paste0("N: ",maxn,"; rho_mz: ",r1,"; rho_dz: ",r2,"; delta: ",rdiff)
    data1   <- cbind(n = tot_n,mzdz = mzdz,        mz = n_p1[,1],dz = n_p1[,2] , power1 = z_power1)
    data2   <- cbind(n = maxn, mzdz_vec = mzdz_vec,mz = n_p2[,1],dz = n_p2[,2] , power2 = z_power2)
    list(data1 =data1, 
         data2 = data2, 
         params1 = params1,
         params2 = params2 )
    })
  
  output$datatable <-
    renderTable({
      dt <- mydata()[["data"]]
      dt
    })
    

  output$graph1 <- renderPlot({
   p <- ggplot(as.data.frame(mydata()[["data1"]]),
        aes(x=mz, y=n, group=as.character(round(ref,2))))
   p <- p +
     geom_line(aes(colour = as.character(round(ref,2))), size=1, alpha=.75) +
     ggtitle(paste0("Power estimate given parameters (",mydata()[["params1"]],")"))+
     scale_y_continuous(name="N")+
     scale_x_continuous(labels = comma, name="MZ???",limits = c(0,1), expand = c(0,0) ) + 
     labs(colour = "Normal ordinate")
   print(p)
  })
  
}
```

```{r}
ui <- fluidPage(

    plotOutput("graph1"),
    tableOutput("datatable")


)
```

```{r}
shinyApp(ui = ui, server = server)
```


