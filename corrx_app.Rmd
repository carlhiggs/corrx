---
title: "Corrx: Classical Twin Study Power Calculator and Simulation Reference"
output: 
  flexdashboard::flex_dashboard:
    orientation: rows
    vertical_layout: fill
    source_code: embed
    theme: flatly
runtime: shiny

---


```{r global, include=FALSE}
# Carl Higgs, 2019

library(flexdashboard)
library(knitr)
library(shiny)
library(ggplot2)
library(scales)
library(dplyr)
library(reshape2)
library(data.table)
library(shinyWidgets)

corrx_1k_sim <-read.csv("corrx_1k_subset.csv",  header = TRUE, stringsAsFactors=FALSE) 
  
```
About
=========================

Background / Instructions

Some text about

What this does

and

why

Power by sample size
=========================

Inputs {.sidebar}
-----------------------------------------------------------------------
An interactive calculator of power for detecting difference in correlations.  Lorum Ipsom.

Twins Research Australia, 2019.
```{r}
# Sample size (x) vs power (y), as for Stata graphs/previous version of app
# shiny inputs defined here
hr()

sliderInput("maxn", "Maximum N:", 
            min=30, max=1000, value=100, step=1)

sliderInput("mzdz", "Ratio of Mz to Dz twin:", 
            min=0, max=10, value=1, step=0.01)
 
sliderInput("r1", "Corr(x,y) in Mz twins:", 
            min=0, max=1, value=0.6, step=0.01)

sliderInput("r2", "Corr(x,y) in Dz twins:", 
            min=0, max=1, value=0.2, step=0.01)

```


```{r}
mydata <- reactive({
    # Model Parameters:
      r1        <- input$r1
      r2        <- input$r2
      rdiff     <- r1 - r2
      maxn      <- input$maxn
      mzdz      <- input$mzdz
      # alpha     <- input$alpha
      sidedness <- 2
      # method    <- input$method
      method    <- "pearson"
      # Step 1: calculate Fisher's Z
      z1        <- atanh(r1)
      z2        <- atanh(r2)
      # Step    2: take difference
      zdiff     <- z1-z2
      # Step    3: calculate standard errmzor and test statistic
      tot_n         <- 15:maxn
      mzdz_vec <- seq(0,10,0.01)
      # n_p1         <- cbind(mz = tot_n*mzdz,dz = tot_n*(1-mzdz))
      n_p1         <- cbind(mz = tot_n/(mzdz+1)*mzdz,dz = tot_n/(mzdz+1))
      n_p2         <- cbind(mz = maxn/(mzdz_vec+1)*mzdz_vec,dz = maxn/(mzdz_vec+1))
      z_se_p1      <- sqrt(rowSums(1/(n_p1-3)))
      z_se_p2      <- sqrt(rowSums(1/(n_p2-3)))
      z_test_p1    <- zdiff/z_se_p1
      z_test_p2    <- zdiff/z_se_p2
      # optionally return p-value for observing diff at least this large under H0
      # z_p    <- sidedness*pnorm(-abs(z_test))
      z_ref    <- c(qnorm(1-0.1/2),qnorm(1-0.05/2))
      z_power1a <- 1-pnorm(z_ref[1] - abs(z_test_p1))
      z_power1b <- 1-pnorm(z_ref[2] - abs(z_test_p1))
      z_power1  <- rbind(cbind(z_power1a,z_ref[1]),cbind(z_power1b,z_ref[2]))
      z_power2a <- 1-pnorm(z_ref[1] - abs(z_test_p2))
      z_power2b <- 1-pnorm(z_ref[2] - abs(z_test_p2))
      z_power2  <- rbind(cbind(z_power2a,z_ref[1]),cbind(z_power2b,z_ref[2]))
      colnames(z_power1) <- colnames(z_power2) <- c("power","ref")
      
    # Collect and output results
    params1 <- paste0("MZ:DZ ratio: ",mzdz,"; rho_mz: ",r1,"; rho_dz: ",r2,"; delta: ",rdiff)
    params2 <- paste0("N: ",maxn,"; rho_mz: ",r1,"; rho_dz: ",r2,"; delta: ",rdiff)
    data1   <- cbind(n = tot_n,mzdz = mzdz,        mz = n_p1[,1],dz = n_p1[,2] , power1 = z_power1)
    data2   <- cbind(n = maxn, mzdz_vec = mzdz_vec,mz = n_p2[,1],dz = n_p2[,2] , power2 = z_power2)
    list(data1 =data1, 
         data2 = data2, 
         params1 = params1,
         params2 = params2 )
    })
    
```


Row {.tabset .tabset-fade}
-------------------------------------

### Power by sample size 

```{r}

renderPlot({
   p <- ggplot(as.data.frame(mydata()[["data1"]]),
        aes(x=n, y=power, group=as.character(round(ref,2))))
   p <- p +
     geom_line(aes(colour = as.character(round(ref,2))), size=1, alpha=.75) +
     ggtitle(paste0("Power estimate given parameters (",mydata()[["params1"]],")"))+
     scale_x_continuous(name="N")+
     scale_y_continuous(labels = comma, name="Power",limits = c(0,1), expand = c(0,0) ) + 
     labs(colour = "Normal ordinate")
   print(p)
  })

```

### Power by ratio 

```{r}

renderPlot({
    p <- ggplot(as.data.frame(mydata()[["data2"]]),
                aes(x=mzdz_vec, y=power, group=as.character(round(ref,2))), log="x")
    p <- p +
      geom_line(aes(colour = as.character(round(ref,2))), size=1, alpha=.75) +
      ggtitle(paste0("Power estimate given parameters (",mydata()[["params2"]],")"))+
      scale_x_continuous(name="MZ:DZ ratio (log scale)", trans='log',limits = c(0.1,10),breaks=c(0.1,seq(0.2,1,0.2),seq(2,10,2)))+
      scale_y_continuous(labels = comma, name="Power",limits = c(0,1), expand = c(0,0) ) + 
      labs(colour = "Normal ordinate")
    print(p)
  })
```

### Power table
```{r}

renderTable({
      mydata()[["data2"]]
    })
```

Sample size by correlation
=========================


Inputs {.sidebar}
-----------------------------------------------------------------------

An interactive calculator of power for detecting difference in correlations.  The calculator uses either an analytic formula, or draws upon pre-processed simulation power results for a given set of scenario parameters.

Twins Research Australia, 2019.

```{r}
# Current graph with rMZ (x) against log(sample size) as y
# shiny inputs defined here
hr()

selectInput("power", "Select target power proportion: ", choices =c(.8, .9) ,selected = .8)
selectInput("skewness", "Select variable skewness: ", choices =c('normal', 'mild', 'extreme') ,selected = 'normal')
selectInput("corr_method", "Select correlation method: ", choices =c('Pearson', 'Spearman') ,selected = 'normal')
# selectInput("power_method", "Select Fisher's Z implementation: ", choices =c('analytical', 'simulation') ,selected = 'analytical')
# sliderInput("ratio", "Ratio of Mz to Dz twin:", min=0, max=10, value=1, step=1)
sliderTextInput("ratio","Ratio value of Mz to Dz twins:",
                            choices=c(0.015625,0.03125,0.0625,0.125,0.25,0.5,1,2,4,8,16,32,64),
                            selected=1, grid = T)



# sliderInput("rho1", "Corr(x,y) in Mz twins:",min=0, max=1, value=0.6, step=0.01)
sliderInput("rho2", "Corr(x,y) in Dz twins:",min=0.1, max=.9, value=0.7, step=0.1)
    
hr()

```


Outputs
-----------------------------------------------------------------------
    
### Calculator (<i>set parameters to view plot</i>)
```{r}

# filter data
obs <- reactive({
  corrx_1k_sim %>%
        filter(method  == tolower(input$corr_method) &
                 dist  == input$skewness    &
                 n1/n2 == input$ratio       &
                 rho2  == input$rho2        &
                 fz    >= input$power
              ) %>%
        select(n1,n2,rho1,fz_nosim,fz)  %>%
        mutate(n = n1 + n2) %>%
        mutate(log_n = log2(n)) %>%
        # select(n,log_n,rho1,fz_nosim,fz)  %>%
        select(n,log_n,rho1,fz)  %>%
        melt(
           id.vars=c("n","log_n","rho1"),
          # measure.vars=c("fz_nosim","fz"),
          measure.vars=c("fz"),
          variable.name="test",
          value.name="power")
  })
```



```{r}

renderPlot({
    
    # fitted values (interpolated over observed)
    fit <- data.table()
      fit <- rbind(fit,
                   cbind("n"    = min(obs()[,"n"]):max(obs()[,"n"]),
                         "rho1" = splinefun(obs()[,"log_n"],
                                            obs()[,"rho1"],
                                            # method = "monoH.FC")(log2(min(obs()$n):max(obs()$n)))))
                                            method = "monoH.FC")(log2(min(obs()$n):max(obs()$n)))))
    fit$n <- as.integer(fit$n)
    fit$rho1 <- as.double(fit$rho1)
    # define plot title
    title <- paste0("Power to detect difference in ",input$corr_method," correlations >= ",input$power,
                    ", by sample size and trait correlation in MZ twins\n",
                    input$dist,"\n",
                    "DZ rho: (",input$rho2,")",
                    "; Mz to Dz ratio: ",input$ratio, "; sims: 1000")
    # initialise plot
    # p <- ggplot(NULL, aes(x = rho1, y = n, colour = test, group = test))+ 
    p <- ggplot(NULL, aes(x = rho1, y = n))+ 
      scale_y_continuous(trans='log2',bquote(N~(log[2]~scale)), 
                         breaks = unique(obs()$n),
                         limits = c(30,1920)) +
      scale_x_continuous(bquote(rho[MZ]), 
                         breaks = seq(0,1,0.1),
                         limits = c(0,1)) +
      geom_smooth(data = obs(),se=FALSE)  +
      # scale_colour_discrete(name="Tests (req. n)"
                            # ,
                            # breaks=cross$test,
                            # labels=cross$label
                            # )  +
      theme(panel.grid.minor = element_blank(),
            panel.background = element_blank(), 
            axis.line = element_line(colour = "black")) +
      ggtitle(title)
    print(p)
  })
# }
```



